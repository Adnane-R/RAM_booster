####################
# Global Variables #
####################

#/boot and / of the Original OS
ROOT_UUID=$(cat /var/lib/ram_booster/conf | grep ROOT_UUID= | sed 's/ROOT_UUID=//g')
BOOT_UUID=$(cat /var/lib/ram_booster/conf | grep BOOT_UUID= | sed 's/BOOT_UUID=//g')
HOME_UUID=$(cat /var/lib/ram_booster/conf | grep HOME_UUID= | sed 's/HOME_UUID=//g')
EFI_UUID=$(cat /var/lib/ram_booster/conf | grep EFI_UUID= | sed 's/EFI_UUID=//g')
DEST=$(cat /var/lib/ram_booster/conf | grep DEST= | sed 's/DEST=//g')
#Remove leading slash from $DEST
DEST="${DEST#/}"
Orig_OS='/mnt/Original_OS/'

#Mount $DEST (RAM Session)
#If function is passed "root_only" as arg, only mount $ROOT_UUID to
#$Orig_OS and nothing else
MOUNT_RS()
{
	#If the $Orig_OS folder exists, check if
	#anything is using it as a mount point
	if [[ -d "$Orig_OS" ]]
	then
		#If something is mounted, exit with an error
		if mountpoint -q "$Orig_OS"
		then
			echo "Failed to mount RAM Session. Is it already mounted?"
			exit 1
		fi

		#Try to remove the $Orig_OS
		sudo rmdir "$Orig_OS" &>/dev/null

		#If removing the $Orig_OS folder fails, like if it's
		#not empty, exit with an error
		if [[ "$?" != "0" ]]
		then
			echo "Failed to remove old $Orig_OS folder."
			echo "Does it have files in it?"
			exit 1
		fi
	fi

	#Make Orig_OS folder
	sudo mkdir -p "$Orig_OS"

	#Try to mount $ROOT_UUID to $Orig_OS
	sudo mount --uuid $ROOT_UUID "$Orig_OS" &>/dev/null ||
	{
		echo "Failed to mount $ROOT_UUID $Orig_OS"
		UMOUNT_RS
		exit 1
	}

	#If this function was passed the arg "root_only", return here
	if [[ "$1" == "root_only" ]]
	then
		return 0
	fi
	
	#Bind /proc
	sudo mount -o bind /proc "$Orig_OS/$DEST/proc" ||
	{
		echo "Failed to bind /proc to ${Orig_OS%/}/${DEST%/}/proc"
		UMOUNT_RS
		exit 1
	}

	#Bind /dev
	sudo mount -o bind /dev "$Orig_OS/$DEST/dev" ||
	{
		echo "Failed to bind /dev to ${Orig_OS%/}/${DEST%/}/dev"
		UMOUNT_RS
		exit 1
	}

	#Bind /dev/pts
	sudo mount -o bind /dev/pts "$Orig_OS/$DEST/dev/pts" ||
	{
		echo "Failed to bind /dev/pts to ${Orig_OS%/}/${DEST%/}/dev/pts"
		UMOUNT_RS
		exit 1
	}

	#Bind /sys
	sudo mount -o bind /sys "$Orig_OS/$DEST/sys" ||
	{
		echo "Failed to bind /sys to ${Orig_OS%/}/${DEST%/}/sys"
		UMOUNT_RS
		exit 1
	}

	#Bind /run
	sudo mount -o bind /run "$Orig_OS/$DEST/run" ||
	{
		echo "Failed to bind /run to ${Orig_OS%/}/${DEST%/}/run"
		UMOUNT_RS
		exit 1
	}

	#Mount /boot, if it's not on the same partition as /
	if [[ "$BOOT_UUID" != "$ROOT_UUID" ]]
	then
		sudo mount --uuid $BOOT_UUID "$Orig_OS/$DEST/boot" ||
		{
			echo "Failed to mount $BOOT_UUID to ${Orig_OS%/}/${DEST%/}/boot"
			UMOUNT_RS
			exit 1
		}
	fi

	#Mount /boot/efi, if we are running an efi system
	if [[ -d /sys/firmware/efi ]] && [[ "$EFI_UUID" != "None" ]]
	then
		sudo mount --uuid $EFI_UUID "$Orig_OS/$DEST/boot/efi" ||
		{
			echo "Failed to mount $EFI_UUID to ${Orig_OS%/}/${DEST%/}/boot/efi"
			UMOUNT_RS
			exit 1
		}
	fi
	
	#Mount /home, if it's not on the same partition as /
	if [[ "$HOME_UUID" != "$ROOT_UUID" ]]
	then
		sudo mount --uuid $HOME_UUID "$Orig_OS/$DEST/home" ||
		{
			echo "Failed to mount $HOME_UUID to ${Orig_OS%/}/${DEST%/}/home"
			UMOUNT_RS
			exit 1
		}
	fi

	#Setup mtab
	sudo chroot "$Orig_OS/$DEST/" /bin/bash -c "grep -v rootfs /proc/mounts > /etc/mtab"

	#Enable X
	xhost +local: >/dev/null
}

#Unmount $DEST (RAM Session)
UMOUNT_RS()
{
	#On the off chance whatever script runs UMOUNT_RS hasn't set
	#$DEST, error out instead of killing whatever half-matches
	[[ -z $DEST ]] && { echo "\$DEST cannot be empty"; exit 1; }	

	CHROOT=${Orig_OS%/}/${DEST#/}

	#Find processes who's root folder is actually the chroot
	for ROOT in $(find /proc/*/root)
	do
		LINK=$(readlink -f $ROOT)
		if echo $LINK | grep -q ${CHROOT%/}
		then
			PID=$(basename $(dirname "$ROOT"))

			#Try to kill it nicely
			kill -0 $PID &>/dev/null && kill -15 $PID

			#Check every second for 5 seconds to see if $PID is dead
			WAIT_TIME=5

			#Do a quick check to see if it's still running
			#It usually takes a second, so this often doesn't help
			kill -0 $PID &>/dev/null &&
			for SEC in $(seq 1 $WAIT_TIME)
			do
				sleep 1

				if [[ "$SEC" != $WAIT_TIME ]]
				then
					#If it's dead, exit
					kill -0 $PID &>/dev/null || break
				else
					#If time's up, kill it
					kill -0 $PID &>/dev/null && kill -9 $PID
				fi  
			done
		fi
	done

	#Unmount all filesystems under $Orig_OS recursively
	sudo umount -R $Orig_OS
	#Remove the temp folder
	sudo rmdir $Orig_OS
}

#Convert input to lowercase
toLower() 
{
	echo $@ | tr "[:upper:]" "[:lower:]" 
}

#Create squashfs image
CreateSquashfs()
{
	echo "Creating squashfs image"
	echo

	#Mount only the root filesystem of the Original OS
	MOUNT_RS root_only

	#Create squashfs image
	#Note: We do NOT write the file directly to the one we boot
	#from so that if the process gets interrupted and we reboot,
	#we can still boot into the old image
	sudo mksquashfs ${Orig_OS%/}/${DEST#/} ${Orig_OS%/}/live/filesystem.squashfs.new -noappend -always-use-fragments

	#If there was an error, exit 1
	if [[ "$?" != "0" ]]
	then
		echo
		echo "Failed to create ${Orig_OS%/}/live/filesystem.squashfs"
		UMOUNT_RS
		exit 1
	fi

	#Move the newly created squashfs image to the location we boot from
	sudo mv ${Orig_OS%/}/live/filesystem.squashfs.new ${Orig_OS%/}/live/filesystem.squashfs

	#Inform user we are done
	echo "mksquashfs created successfully"

	#Unmount the root filesystem
	UMOUNT_RS
}
