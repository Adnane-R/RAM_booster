#!/bin/bash

#Written On: Dec 2014
#Written By: Tal
#Written For: Ubuntu Forums Community
#Description: 
#	This script downloads the latest bug fixes to the RAM Booster project
#	Note: This script is:
#		1. self-reliant (does NOT source rlib, in case rlib is
#			broken or not updated yet)
#		2. can be run from any dir in the RAM Session, in case it
#			got uninstalled from /usr/sbin/ somehow

############################
# Only run if user is root #
############################

uid=$(/usr/bin/id -u) && [ "$uid" = "0" ] ||  
{
        clear
        echo "You must be root to run $0."
        echo "Try again with the command 'sudo $0'"
        exit 1
} 

##################################################################################
# Check if the user is trying to run this script from outside of the RAM Session #
##################################################################################

if [ ! -e /RAM_Session ]
then
        clear
        echo "This script cannot be run from outside of the RAM Session."
        exit 0
fi

##########################################################################
# Check if the user is trying to run this script from inside of a chroot #
##########################################################################

if [[ "$(ls -di / | cut -d ' ' -f 1)" != 2 ]] && [[ "$(ls -di / | cut -d ' ' -f 1)" != 128 ]]
then
        echo "This script cannot be run from inside of a chroot"
        exit 0
fi

###################
# Check arguments #
###################

#If true, user chose to only check for updates - not apply them
#false otherwise
CHECK_ONLY=false

if [[ $# != 0 ]] && [[ $# != 1 ]]
then
	echo "Invalid number of arguments"
	exit 1
fi

case $1 in
	"")
		#No arguments is fine
		;;
	--check)
		CHECK_ONLY=true
		;;
	*)
		echo "Error: \"$1\" is an invalid argument"
		exit 1
		;;
esac

#############################
# Check if git is installed #
#############################

if ! dpkg -l git | grep -q $'^ii[ \t]*git[ \t]'
then
        clear
        echo "You need to install git before running this script"
        echo "Try running \"sudo apt-get install git\""
        exit 1
fi

#########################################################
# Download the latest version of the RAM Booster script #
#########################################################

#Delete it if it's left over from a previous attempt to update
if [[ -d /tmp/RAM_Booster ]]
then
	rm -rf /tmp/RAM_Booster
fi

git clone git://github.com/terminator14/RAM_Booster.git /tmp/RAM_Booster &>/dev/null

if [[ $? != 0 ]]
then
	echo "Failed to download RAM_Booster git repo"
	exit 1
fi

################
# Setup a trap #
################

#Note: Trap fires on Ctrl+C AND anytime the script exits
trap 'UMOUNT_ROOT; sudo rm -rf /tmp/RAM_Booster' EXIT SIGINT

############################################################
# Figure out the path of the script folder in the git repo #
############################################################

OS_NAME=$(cat /etc/os-release | grep PRETTY_NAME | grep -o "\"[^\"]*\"" | tr -d '"')
UBUNTU_VERSION=$(cat /etc/os-release | grep VERSION_ID | grep -o "\"[^\"]*\"" | tr -d '"')
if [[ -d /tmp/RAM_Booster/extras_$UBUNTU_VERSION ]]
then
	SCRIPT_DIR=extras_$UBUNTU_VERSION
elif [[ -d /tmp/RAM_Booster/old/extras_$UBUNTU_VERSION ]]
then
	SCRIPT_DIR=old/extras_$UBUNTU_VERSION
	echo "The script for your version of Ubuntu ($OS_NAME) appears to be old"
	echo "You may want to check if the RAM Booster script exists for a newer"
	echo "version of Ubuntu, and if so, update your system and use the new script"
	echo
else
	echo "A script for $OS_NAME could not be found in the github RAM Booster repo"
	exit 1
fi

####################
# Global Variables #
####################

Orig_OS='/mnt/Original_OS/'
#Figure out $DEST
DEST=$(cat /var/lib/ram_booster/conf | grep -v '^#' | grep DEST= | sed 's/DEST=//g')
#Remove leading slash from $DEST
DEST="${DEST#/}"
#UUID of / on the Original OS
ROOT_UUID=$(cat /var/lib/ram_booster/conf | grep -v '^#' | grep ROOT_UUID= | sed 's/ROOT_UUID=//g')

##############################################################################
####                             FUNCTIONS                                ####
#### NOTE: MOST OF THESE ARE SIMPLIFIED VERSIONS OF FUNCTIONS PROVIDED BY ####
####    RLIB FOR THE PURPOSE OF SELF-RELIANCE OF THE RUPGRADE SCRIPT      ####
##############################################################################

#Mounts the Original OS
#Note: This does what rlib already does, since this script must be self-reliant
MOUNT_ROOT() {
        #If the $Orig_OS folder exists, check if
        #anything is using it as a mount point
        if [[ -d "$Orig_OS" ]]
        then
                #If something is mounted, exit with an error
                if mountpoint -q "$Orig_OS"
                then
                        echo "Failed to mount RAM Session. Is it already mounted?"
                        exit 1
                fi

                #Try to remove the $Orig_OS
                sudo rmdir "$Orig_OS" &>/dev/null

                #If removing the $Orig_OS folder fails, like if it's
                #not empty, exit with an error
                if [[ "$?" != "0" ]]
                then
                        echo "Failed to remove old $Orig_OS folder."
                        echo "Does it have files in it?"
                        exit 1
                fi
        fi

        #If we are using the default /mnt/Original_OS/ as the mount point,
        #check if anything is using /mnt as a mountpoint
        if echo $Orig_OS | grep -q '^/mnt' && mountpoint -q /mnt
        then
                echo "Failed to mount Original OS. Is something already mounted at /mnt?"
                exit 1
        fi

        #Make Orig_OS folder
        sudo mkdir -p "$Orig_OS"

        #Try to mount $ROOT_UUID to $Orig_OS
        sudo mount --uuid $ROOT_UUID "$Orig_OS" &>/dev/null ||
        {
                echo "Failed to mount $ROOT_UUID to $Orig_OS"
                UMOUNT_RS
                exit 1
        }
}

#Unmounts the Original OS
#Note: Since all we did was add some files to it, and no processes
#actually ran in a chroot, there is no need for all the complexity of
#rlib's UMOUNT_RS (shutting down services, killing processes, etc.)
UMOUNT_ROOT() {
        #Unmount $Orig_OS
        sudo umount $Orig_OS 2>/dev/null

        #Check how it went
        if [[ "$?" == 0 ]]
        then
                #Remove the temp folder
                sudo rmdir $Orig_OS
	else
		echo "Failed to unmount $Orig_OS"
		return 1
        fi
}

#Create squashfs image
MakeSquashfsImage() {
	echo "Some scripts on the RAM Session were updated"
	read -p "Would you like to recreate the squashfs image? [y\N]: " answer

        #Convert answer to lowercase
        answer=$(toLower $answer)

        case $answer in
                y|yes)
                        #Fall through and create the image
                        ;;
                n|no)
			echo
			echo "You chose to NOT recreate the squashfs image, even though updates were applied"
			echo "If you change your mind, run 'sudo redit -s'"

			return
			;;
	esac
			

        echo "Creating squashfs image"
        echo

        #Create squashfs image
        #Note: We do NOT write the file directly to the one we boot
        #from so that if the process gets interrupted and we reboot,
        #we can still boot into the old image
        sudo mksquashfs ${Orig_OS%/}/${DEST#/} ${Orig_OS%/}/live/filesystem.squashfs.new -noappend -always-use-fragments

        #If there was an error, exit 1
        if [[ "$?" != "0" ]]
        then
                echo
                echo "Failed to create ${Orig_OS%/}/live/filesystem.squashfs"
                return 1
        fi

        clear

        #Move the newly created squashfs image to the location we boot from
        sudo mv ${Orig_OS%/}/live/filesystem.squashfs.new ${Orig_OS%/}/live/filesystem.squashfs

        #Inform user we are done
        echo "squashfs image created successfully"
        echo "reboot to use it"
}

#Take exactly 4 args:
# 1. Path to script in the git repo
# 2. Path to script in the filesystem when installed
# 3. Permissions in the form (###)
# 4. Ownership in the form user:group
#Returns:
# 0: Updates successful
# 1: Updates not required
# 2: Updates required, but not done (--check mode)
# 3: Updates failed
CheckForUpdates() {
	GIT_SCRIPT=$1
	INSTALLED_SCRIPT=$2
	PERMS=$3
	OWNER=$4

	#Check permissions arg
	#Note: Mostly for debugging - user should never see this error
	if ! echo $PERMS | grep -qx '[0-9]\{3\}'
	then
		echo "Invalid permissions passed to CheckForUpdates function"
		exit 1
	fi

	#Check ownership arg
	#Note: Mostly for debugging - user should never see this error
	if ! echo $OWNER | grep -qx '[a-Z]:[a-Z]'
	then
		echo "Invalid ownership passed to CheckForUpdates function"
		exit 1
	fi

	################################
	# Check file on running system #
	################################

	#Check if the script exists in the git repo we just downloaded
	if [[ ! -e $GIT_SCRIPT ]]
	then
		echo "The latest version of the git repo does not have the $(basename $GIT_SCRIPT) script"
		return 3
	fi

	#Check if script is installed in the running system
	if [[ ! -e $INSTALLED_SCRIPT ]]
	then
		if $CHECK_ONLY
		then
			echo "$INSTALLED_SCRIPT not installed"
			return 2
		else
			echo "Installing $INSTALLED_SCRIPT"
			sudo cp $GIT_SCRIPT $INSTALLED_SCRIPT
			sudo chmod $PERMS $INSTALLED_SCRIPT
			sudo chown $OWNER $INSTALLED_SCRIPT
		fi
	fi

	#Check the md5s
	MD5_OF_REPO_FILE=$(md5sum $GIT_SCRIPT | cut -d ' ' -f 1)
	MD5_OF_INSTALLED_FILE=$(md5sum $INSTALLED_SCRIPT | cut -d ' ' -f 1)

	if [[ $MD5_OF_REPO_FILE != $MD5_OF_INSTALLED_FILE ]]
	then
		if $CHECK_ONLY
			echo "$INSTALLED_SCRIPT: update available"
			return 2
		else
			echo "Updating $INSTALLED_SCRIPT"

			sudo rm -f $INSTALLED_SCRIPT
			sudo cp $GIT_SCRIPT $INSTALLED_SCRIPT
			sudo chmod $PERMS $INSTALLED_SCRIPT
			sudo chown $OWNER $INSTALLED_SCRIPT

			return 0
		fi
	else
		echo "$INSTALLED_SCRIPT: up to date"
		return 1
	fi

	################################
	# Check file on squashfs image #
	################################

	#Check if the script exists in the RAM Session
	if [[ ! -e ${Orig_OS}/${DEST}/$INSTALLED_SCRIPT ]]
	then
		if $CHECK_ONLY
		then
			echo "$INSTALLED_SCRIPT not installed on squashfs image"
			return 2
		else
			echo "Installing $INSTALLED_SCRIPT on squashfs image"
			sudo cp $GIT_SCRIPT ${Orig_OS}/${DEST}/$INSTALLED_SCRIPT
			sudo chmod $PERMS ${Orig_OS}/${DEST}/$INSTALLED_SCRIPT
			sudo chown $OWNER ${Orig_OS}/${DEST}/$INSTALLED_SCRIPT
		fi
	fi

	#Check the md5 of ${Orig_OS}/${DEST}/$INSTALLED_SCRIPT
	MD5_OF_INSTALLED_FILE_ON_DEST=$(md5sum ${Orig_OS}/${DEST}/$INSTALLED_SCRIPT | cut -d ' ' -f 1)

	if [[ $MD5_OF_REPO_FILE != $MD5_OF_INSTALLED_FILE_ON_DEST ]]
	then
		if $CHECK_ONLY
		then
			echo "$INSTALLED_SCRIPT on squashfs image: update available"
			return 2
		else
			echo "Updating $INSTALLED_SCRIPT on squashfs image"

			sudo rm -f ${Orig_OS}/${DEST}/$INSTALLED_SCRIPT
			sudo cp $GIT_SCRIPT ${Orig_OS}/${DEST}/$INSTALLED_SCRIPT
			sudo chmod $PERMS ${Orig_OS}/${DEST}/$INSTALLED_SCRIPT
			sudo chown $OWNER ${Orig_OS}/${DEST}/$INSTALLED_SCRIPT

			return 0
		fi
	else
		echo "$INSTALLED_SCRIPT on squashfs image: up to date"
		return 1
	fi
}

##############################################################################
####                           MAIN SCRIPT                                ####
##############################################################################

#Mount root
MOUNT_ROOT

#Check for updates

#Create squashfs image
if $UPDATES_PERFORMED
then

fi

#Unmount
