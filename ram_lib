#Convert input to lowercase
toLower() 
{
	echo $@ | tr "[:upper:]" "[:lower:]" 
}

#Ask user if he really wants to uninstall
#Note: Does NOT actually uninstall - that would be the
#	Uninstall_RAM_Booster function
Uninstall_Prompt() {
	echo "This will delete your RAM Session completely!"
	read -p "Would you like to proceed with the uninstall? [y/N]: " answer

	#Convert answer to lowercase
	answer=$(toLower $answer)

	case $answer in
		y|yes)
			Uninstall_RAM_Booster
			exit 0
			;;  
		*) 
			echo "Uninstall Cancelled"
			exit 0
			;;  
	esac
}

#Actually uninstalls the RAM Session
Uninstall_RAM_Booster() {
	echo Uninstalling...
}

#Allows usage of "ECHO" instead of "echo"
#for long sentences that need to be wrapped
ECHO() {
	echo "$@" | fmt -w `tput cols`
}

#Ask user what device he wants to use for /home
Ask_User_About_Home() {
	#Ask user which partition to use for /home
	clear
	ECHO "Which partition do you want to use as /home?"
	read -p "Your choice: " -e HOME_DEV

	#Check if device exists
	if [[ ! -b "$HOME_DEV" ]]
	then
		echo
		ECHO "\"$HOME_DEV\" is not a valid device. Please rerun the script and specify the device name of a partition or logical volume."
		echo "Exiting..."
		exit 1
	fi

	#Make sure the device is a partition (not an entire physical drive) or a logical volume
	if ! (echo $HOME_DEV | grep -q '/dev/sd[a-z][0-9]') && ! (sudo lvdisplay $HOME_DEV &>/dev/null)
	then
		echo
		ECHO "\"$HOME_DEV\" is neither a partition, nor a logical volume. Please rerun the script and specify the device name of a partition or logical volume."
		echo "Exiting..."
		exit 1
	fi

	#Make sure the device is really empty
	echo -e "Running file check on your device...\n"

	#Make sure an /mnt/tmp doesn't exist from an earlier exit of
	#our script
	if [[ -d /mnt/tmp ]]
	then
		sudo umount /mnt/tmp 2>/dev/null >/dev/null
	else
		sudo mkdir -p /mnt/tmp
	fi

	sudo mount $HOME_DEV /mnt/tmp 2>/dev/null

	#Check if there were problems mounting the device
	if [[ "$?" != 0 ]]
	then
		ECHO "There was a problem with the device you gave. It would not mount. If this is a brand new drive and the partition has never been formatted, please format it as ext4 before running this script. Otherwise, please fix the problem before rerunning the script."
		echo
		echo "Exiting..."
		sudo rmdir /mnt/tmp
		exit 1
	fi

	#If user hits Ctrl+C, unmount /mnt/tmp
	trap 'sudo umount /mnt/tmp 2>/dev/null && sudo rmdir /mnt/tmp; echo; exit 1' SIGINT

	#Count how many files are on the newly mounted device
	FILE_COUNT=`sudo ls -lR /mnt/tmp | grep ^- | wc -l`
	if [[ "$FILE_COUNT" -gt 0 ]]
	then
		clear
		ECHO "The device you chose is NOT empty! Are you sure you want to delete all data on it? Type \"I am sure\" to proceed, or \"ls\" to see what's on the device you chose."
		echo
		read -p "Your choice: " answer

		#Convert answer to lowercase
		answer=$(toLower $answer)

		echo

		if [[ "$answer" == "ls" ]]
		then
			#Without running in the background, nautilus doesn't release the terminal
			nautilus /mnt/tmp 2>/dev/null >/dev/null &
			clear
			echo "Do you still wish to format the device and erase all this data? Type \"I do\" to proceed or anything else to exit." | fmt -w `tput cols`
			echo
			read -p "Your choice: " answer

			#Convert answer to lowercase
			answer=$(toLower $answer)

			if [[ "$answer" == "i do" ]]
			then
				echo -e "Formatting $HOME_DEV\n"
			else
				echo "Exiting..."
				sudo umount /mnt/tmp && sudo rmdir /mnt/tmp
				exit 1
			fi
		elif [[ "$answer" == "i am sure" ]]
		then
			echo -e "Formatting $HOME_DEV\n"
		else
			echo "$answer is an invalid choice"
			echo "Exiting..."
			sudo umount /mnt/tmp && sudo rmdir /mnt/tmp
			exit 1
		fi
	else
		echo "Everything checks out."
		echo -e "Formatting $HOME_DEV\n"
	fi

	#Unmount the device
	sudo umount /mnt/tmp
	sudo rmdir /mnt/tmp

	#Clear trap
	trap - SIGINT

	#Format the device
	sudo mkfs.ext4 -L home $HOME_DEV

	#Check if there was a problem formatting the device
	if [[ "$?" != 0 ]]
	then
		echo
		echo "Formatting $HOME_DEV failed."
		echo "Exiting..."
		exit 1
	else
		echo "$HOME_DEV formatted successfully"
		sleep 4
	fi
}

CtrlC()
{
	echo
	ECHO "You interupted the script while it was running. Would you like to revert all the changes it made so you can start fresh next time you run the script?"
	ECHO "WARNING: This will delete any existing RAM Session!"
	echo
	read -p "Your choice [Y/n]: " answer

	#Convert answer to lowercase
	answer=$(toLower $answer)

	case "$answer" in
	n|no)
		echo
		ECHO "If you say so. You may want to run \"$0 --uninstall\" however before running the script again, just to make sure nothing is left to get in its way."
		exit 0
		;;
	*)
		echo
		#Note: Normally, we would use the Uninstall_Prompt function, but since we already confirmed
		#that the user wants to do this, and since it's relatively safe, since the RAM Session is
		#presumably empty (we were just installing it), we run the Uninstall_RAM_Booster function instead
		Uninstall_RAM_Booster
		exit 0
		;;
	esac
}

#Add grub2 entry
GrubEntry()
{
	#Adding entry to Grub2 menu
	echo "Adding entry to Grub2 menu"

	(
		cat << $'\t06_RAMSESS'
		#!/bin/sh -e

		MOD_DIR=$(if [ -e /Original_OS ]; then echo /var/squashfs/lib/modules/; elif [ -e /RAM_Session ]; then echo /lib/modules/; fi)
		KER_NAME=$(for KERN in $(ls /boot/ | grep vmlinuz | sed 's/vmlinuz-//g' | sort -r -t"." -k1,1n -k2,2n -k3,3n | sed 's/.efi.signed//'); do [ -d $MOD_DIR/$KERN ] && { echo $KERN; break; }; done)
		GRUB_CMDLINE_LINUX_DEFAULT=$([ -e /etc/default/grub ] && cat /etc/default/grub | grep GRUB_CMDLINE_LINUX_DEFAULT | grep -o '["].*["]' | tr -d '"')

		if [ -z "$KER_NAME" ]
		then
			KER_NAME=$(uname -r)
		fi

		echo "Found RAM Session image: /boot/vmlinuz-$KER_NAME" >&2

		cat << EOF

		menuentry "Ubuntu to RAM" {
		  set uuid_grub_boot=BOOT_UUID
		  set uuid_os_root=ROOT_UUID

		  search --no-floppy --fs-uuid \$uuid_grub_boot --set=grub_boot

		  set grub_boot=(\$grub_boot)

		  if [ \$uuid_grub_boot == \$uuid_os_root ] ; then                 
		     set grub_boot=\$grub_boot/boot
		  fi

		  linux \$grub_boot/vmlinuz-$KER_NAME bootfrom=/dev/disk/by-uuid/\$uuid_os_root boot=live toram=filesystem.squashfs apparmor=0 security="" root=/dev/disk/by-uuid/\$uuid_os_root ro $GRUB_CMDLINE_LINUX_DEFAULT
		  initrd \$grub_boot/initrd.img-$KER_NAME
		}
		EOF
		06_RAMSESS
	) | sed 's/^\t\t//' | sudo tee /etc/grub.d/06_RAMSESS >/dev/null

	#See how it went
	if [[ "$?" != 0 ]]
	then
		echo "Failed to add entry to Grub menu."
		echo "You'll have to do this manually."
	else
		echo "Grub entry added successfully."
	fi

	#Replace BOOT_UUID and ROOT_UUID above with actual values
	sudo sed -i 's/ROOT_UUID/'$ROOT_UUID'/' /etc/grub.d/06_RAMSESS
	sudo sed -i 's/BOOT_UUID/'$BOOT_UUID'/' /etc/grub.d/06_RAMSESS

	#Make script executable
	sudo chmod a+x /etc/grub.d/06_RAMSESS

	#Unhide grub menu by uncommenting line in /etc/default/grub
	sudo sed -i 's/\(GRUB_HIDDEN_TIMEOUT=0\)/#\1/g' /etc/default/grub
}

#Copy the OS to $DEST
CopyFileSystem() {
	echo
	echo "Ready to copy your filesystem to ${DEST}..."
	echo "Press enter to begin"
	#Set timeout incase the user left so the script continues to run
	read -t 60 key

	#Stores rsync arguments that vary between copying /home and mounting it
	RSYNC_OPTIONS=''

	if $COPY_HOME
	then
		RSYNC_OPTIONS='--exclude=.local/share/Trash/files/*'
	else
		RSYNC_OPTIONS='--exclude=/home/*'
	fi

	#Copy the filesystem to $DEST
	sudo rsync -aAXSH -hv --delete --progress / ${DEST} --exclude={"/dev/*",\
	"/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*","/media/*","/etc/mtab",\
	"/live","/Original_OS","${DEST}",/lost+found} $RSYNC_OPTIONS

	#Check how the operation went
	#Exit code 24 indicates some source files vanished, which is pretty
	#normal considering we are copying a filesystem that is currently in use
	case "$?" in
		0|24)
			echo
			echo "Filesystem copied successfully."
			sleep 4
		*)
			echo
			echo "Copying filesystem failed."
			echo
			echo "Exiting..."
			exit 1
			;;
	esac

	if $COPY_HOME
	then
		if $HOME_ALREADY_MOUNTED
		then
			#/home was being mounted, but user chose to copy it instead
			#Remove entry of current partition being used for /home from
			#${DEST}/etc/fstab
			sudo sed -i '/^[^#].*\/home/d' ${DEST}/etc/fstab
		fi
	else
		if ! $HOME_ALREADY_MOUNTED
		then
			#If user chose to use a partition as /home, and
			#the current system wasn't doing it already, modify
			#${DEST}/etc/fstab

			#First, figure out the UUID for the new /home
			HOME_UUID=$(sudo blkid -o value -s UUID $HOME_DEV)

			#Change ${DEST}/etc/fstab
			sudo bash -c 'echo -e "UUID='${HOME_UUID}'\t/home\text4\terrors=remount-ro\t0\t1" >> '${DEST}'/etc/fstab'

			echo
			echo "Copying /home to ${HOME_DEV}..."

			#Mount $HOME_DEV
			sudo mkdir /mnt/tmp
			sudo mount $HOME_DEV /mnt/tmp

			#Copy /home to $HOME_DEV and write down its
			#exit code
			sudo rsync -aAXSH -hv --delete --progress /home/ /mnt/tmp/
			EXIT_CODE="$?"

			#Unmount and remove /mnt/tmp, which we have to do
			#whether the rsync command succedded or not
			sudo umount /mnt/tmp
			sudo rmdir /mnt/tmp

			#Check if rsync was successful
			case "$EXIT_CODE" in
				0|24)
					echo
					echo "/home copied to $HOME_DEV successfully"
					sleep 4
					;;
				*)
					echo
					echo "Failed to copy /home to $HOME_DEV"
					echo
					echo "Exiting..."
					exit 1
					;;
			esac

			#Ask user if they want to share /home
			echo
			ECHO "Would you like to have your Original OS use $HOME_DEV as its /home as well?"
			ECHO "If you choose yes, your Original OS's /home and your RAM Session's /home will be shared"
			ECHO "If you choose no, your Original OS's /home and your RAM Session's /home will be different"
			read -p "Your choice [Y/n]: " answer

			#Convert answer to lowercase
			answer=$(toLower $answer)

			case $answer in
				*)
					sudo bash -c 'echo -e "UUID='${HOME_UUID}'\t/home\text4\terrors=remount-ro\t0\t1" >> /etc/fstab'
					echo
					ECHO "Your /etc/fstab has been modified to mount $HOME_DEV as your /home at boot"
					sleep 4
					;;  
				n|no)  
					#Do nothing
					ECHO "Your Original OS's /home and your RAM Session's /home will remain separate."
					sleep 4
					;;  
			esac

		fi
	fi
}
